# OWON XDM Remote hardware definition
# Complete package for ESP32-C3 based OWON XDM1041 multimeter remote control
# Users should define their own esphome, wifi, api, ota in their device config
#
# Features:
# - UART communication with OWON XDM1041 via SCPI protocol
# - Status LED control
# - WiFi connectivity
# - Automatic multimeter initialization on boot
# - High sampling rate (RATE F) configuration

substitutions:
  friendly_name: "OWON XDM Remote"
  # Default command timeout in seconds
  command_timeout: "1.0"

dashboard_import:
  package_import_url: github://cyberglitchlabs/esphome/packages/owon_xdm_base.yaml
  import_full_config: false

esphome:
  project:
    name: "cyberglitchlabs.owon_xdm_remote"
    version: "1.0.0"
  on_boot:
    - priority: 600  # Run early for logging
      then:
        - logger.log: "OWON XDM Remote booting..."
    - priority: -100  # Run after everything else to initialize multimeter
      then:
        - script.execute: initialize_multimeter

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: arduino

logger:
  level: DEBUG
  baud_rate: 0  # Disable UART logging to avoid conflicts with multimeter UART

# UART configuration for OWON XDM1041
uart:
  id: xdm_uart
  tx_pin: GPIO21
  rx_pin: GPIO20
  baud_rate: 115200
  data_bits: 8
  parity: NONE
  stop_bits: 1

# Status LED (active-low on ESP32-C3 Super Mini)
output:
  - platform: gpio
    pin: GPIO8
    inverted: true
    id: status_led_output

light:
  - platform: binary
    name: "${friendly_name} Status LED"
    output: status_led_output
    id: status_led
    internal: true

button:
  - platform: restart
    name: '${friendly_name} Restart'
    entity_category: diagnostic

  - platform: safe_mode
    name: '${friendly_name} Safe Mode'
    entity_category: config

# Text sensors for SCPI responses and status
text_sensor:
  - platform: template
    name: "${friendly_name} Response"
    id: scpi_response
    icon: "mdi:message-text"

  - platform: version
    name: '${friendly_name} ESPHome Version'
    entity_category: diagnostic

  - platform: wifi_info
    ip_address:
      name: ${friendly_name} WiFi IP Address
      entity_category: diagnostic
    ssid:
      name: ${friendly_name} WiFi SSID
      entity_category: diagnostic
    mac_address:
      name: ${friendly_name} WiFi MAC Address
      entity_category: diagnostic

# Sensors
sensor:
  - platform: uptime
    name: '${friendly_name} Uptime'
    entity_category: diagnostic
    unit_of_measurement: s

  - platform: wifi_signal
    name: "${friendly_name} WiFi Signal"
    id: wifi_signal_sensor
    entity_category: diagnostic
    update_interval: 60s

# Binary sensors for device connectivity
binary_sensor:
  - platform: status
    name: "${friendly_name} Status"
    entity_category: diagnostic

# Startup sequence to initialize the multimeter
script:
  - id: initialize_multimeter
    mode: single
    then:
      - logger.log: "Starting multimeter initialization..."
      - light.turn_on:
          id: status_led
          transition_length: 0s
      - delay: 2s
      
      # Wait for idle line
      - logger.log: "Checking for idle UART line..."
      - delay: 2s
      
      # Query device identification
      - logger.log: "Querying device with *IDN?..."
      - uart.write:
          id: xdm_uart
          data: "*IDN?\r\n"
      - delay: 1s
      - lambda: |-
          std::string response = "";
          while (id(xdm_uart).available()) {
            uint8_t byte;
            id(xdm_uart).read_byte(&byte);
            response += (char)byte;
          }
          ESP_LOGI("xdm", "IDN Response: %s", response.c_str());
      
      # Set high sampling rate
      - logger.log: "Setting high sampling rate (RATE F)..."
      - uart.write:
          id: xdm_uart
          data: "RATE F\r\n"
      - delay: 500ms
      
      # Verify sampling rate
      - logger.log: "Verifying sampling rate (RATE?)..."
      - uart.write:
          id: xdm_uart
          data: "RATE?\r\n"
      - delay: 500ms
      - lambda: |-
          std::string response = "";
          while (id(xdm_uart).available()) {
            uint8_t byte;
            id(xdm_uart).read_byte(&byte);
            response += (char)byte;
          }
          response.erase(0, response.find_first_not_of(" \n\r\t"));
          response.erase(response.find_last_not_of(" \n\r\t") + 1);
          if (response == "F") {
            ESP_LOGI("xdm", "High sampling rate confirmed!");
          } else {
            ESP_LOGW("xdm", "Unexpected rate response: %s", response.c_str());
          }
      
      # Blink LED to indicate success
      - light.turn_off:
          id: status_led
          transition_length: 0s
      - delay: 500ms
      - light.turn_on:
          id: status_led
          transition_length: 0s
      - delay: 500ms
      - light.turn_off:
          id: status_led
          transition_length: 0s
      - delay: 500ms
      - light.turn_on:
          id: status_led
          transition_length: 0s
      
      - logger.log: "Multimeter initialization complete!"
